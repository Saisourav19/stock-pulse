-- Create automated data collection pipeline
-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS pg_cron WITH SCHEMA pg_catalog;
CREATE EXTENSION IF NOT EXISTS pg_net WITH SCHEMA pg_catalog;

-- Create function to get all active symbols
CREATE OR REPLACE FUNCTION get_active_symbols()
RETURNS TABLE (symbol TEXT, company_name TEXT) AS $$
BEGIN
    RETURN QUERY
    SELECT DISTINCT 
        s.symbol,
        COALESCE(s.company_name, 'Unknown') as company_name
    FROM stocks s
    WHERE s.is_active = true
    ORDER BY s.symbol;
END;
$$ LANGUAGE plpgsql;

-- Create function to schedule live data collection
CREATE OR REPLACE FUNCTION schedule_live_data_collection()
RETURNS void AS $$
BEGIN
    -- Schedule stock price updates every 5 minutes during market hours
    SELECT cron.schedule(
        'stock-price-updates',
        '*/5 9-16 * * 1-5',  -- Every 5 minutes, 9 AM to 4 PM, Monday to Friday
        $$
        SELECT net.http_post(
            url := 'https://your-project.supabase.co/functions/v1/live-data-fetcher',
            headers := jsonb_build_object('Authorization', 'Bearer ' || current_setting('app.service_role_key', true)),
            body := jsonb_build_object(
                'symbols', (SELECT array_agg(json_build_object('symbol', symbol, 'companyName', company_name)) FROM get_active_symbols()),
                'includeNews', false
            )
        );
        $$
    );
    
    -- Schedule news updates every 30 minutes
    SELECT cron.schedule(
        'news-updates',
        '*/30 * * * *',  -- Every 30 minutes
        $$
        SELECT net.http_post(
            url := 'https://your-project.supabase.co/functions/v1/live-data-fetcher',
            headers := jsonb_build_object('Authorization', 'Bearer ' || current_setting('app.service_role_key', true)),
            body := jsonb_build_object(
                'symbols', (SELECT array_agg(json_build_object('symbol', symbol, 'companyName', company_name)) FROM get_active_symbols()),
                'includeNews', true
            )
        );
        $$
    );
    
    -- Schedule prediction updates every hour
    SELECT cron.schedule(
        'prediction-updates',
        '0 * * * *',  -- Every hour
        $$
        DO $$
        DECLARE
            symbol_record RECORD;
        BEGIN
            FOR symbol_record IN SELECT symbol FROM get_active_symbols() LOOP
                PERFORM net.http_post(
                    url := 'https://your-project.supabase.co/functions/v1/real-time-predictor',
                    headers := jsonb_build_object('Authorization', 'Bearer ' || current_setting('app.service_role_key', true)),
                    body := jsonb_build_object('symbol', symbol_record.symbol)
                );
                -- Small delay between predictions to avoid rate limits
                PERFORM pg_sleep(1);
            END LOOP;
        END $$;
        $$
    );
    
    -- Schedule prediction verification every 4 hours
    SELECT cron.schedule(
        'prediction-verification',
        '0 */4 * * *',  -- Every 4 hours
        $$
        SELECT net.http_post(
            url := 'https://your-project.supabase.co/functions/v1/verify-predictions',
            headers := jsonb_build_object('Authorization', 'Bearer ' || current_setting('app.service_role_key', true)),
            body := jsonb_build_object('allSymbols', true)
        );
        $$
    );
    
    -- Schedule daily cleanup and maintenance
    SELECT cron.schedule(
        'daily-maintenance',
        '0 2 * * *',  -- 2 AM daily
        $$
        -- Clean up old price data (keep last 90 days)
        DELETE FROM stock_prices WHERE created_at < NOW() - INTERVAL '90 days';
        
        -- Clean up old articles (keep last 30 days)
        DELETE FROM articles WHERE created_at < NOW() - INTERVAL '30 days';
        
        -- Update statistics
        ANALYZE stock_prices;
        ANALYZE articles;
        ANALYZE predictions;
        ANALYZE prediction_history;
        $$
    );
END;
$$ LANGUAGE plpgsql;

-- Create enhanced stock_prices table if it doesn't exist
CREATE TABLE IF NOT EXISTS stock_prices (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    symbol TEXT NOT NULL,
    price DECIMAL(12, 4) NOT NULL,
    change_amount DECIMAL(12, 4),
    change_percent DECIMAL(8, 4),
    volume BIGINT,
    market_cap BIGINT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_stock_prices_symbol 
        FOREIGN KEY (symbol) 
        REFERENCES stocks(symbol) 
        ON DELETE CASCADE
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_stock_prices_symbol_created_at 
ON stock_prices(symbol, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_stock_prices_created_at 
ON stock_prices(created_at DESC);

-- Create enhanced articles table if it doesn't exist
CREATE TABLE IF NOT EXISTS articles (
    id TEXT PRIMARY KEY,
    symbol TEXT NOT NULL,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    source TEXT,
    url TEXT,
    published_at TIMESTAMP WITH TIME ZONE,
    sentiment_pos DECIMAL(5, 4),
    sentiment_neg DECIMAL(5, 4),
    sentiment_neu DECIMAL(5, 4),
    sentiment_compound DECIMAL(5, 4),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_articles_symbol 
        FOREIGN KEY (symbol) 
        REFERENCES stocks(symbol) 
        ON DELETE CASCADE
);

-- Create indexes for articles
CREATE INDEX IF NOT EXISTS idx_articles_symbol_published_at 
ON articles(symbol, published_at DESC);

CREATE INDEX IF NOT EXISTS idx_articles_created_at 
ON articles(created_at DESC);

-- Create predictions table if it doesn't exist
CREATE TABLE IF NOT EXISTS predictions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    symbol TEXT NOT NULL,
    prediction TEXT NOT NULL CHECK (prediction IN ('bullish', 'bearish', 'neutral')),
    confidence DECIMAL(5, 4) NOT NULL CHECK (confidence >= 0 AND confidence <= 1),
    target_price DECIMAL(12, 4),
    timeframe TEXT NOT NULL,
    risk_level TEXT CHECK (risk_level IN ('low', 'medium', 'high')),
    momentum TEXT CHECK (momentum IN ('accelerating', 'decelerating', 'stable')),
    source TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_predictions_symbol 
        FOREIGN KEY (symbol) 
        REFERENCES stocks(symbol) 
        ON DELETE CASCADE
);

-- Create indexes for predictions
CREATE INDEX IF NOT EXISTS idx_predictions_symbol_created_at 
ON predictions(symbol, created_at DESC);

-- Create prediction_history table if it doesn't exist
CREATE TABLE IF NOT EXISTS prediction_history (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    symbol TEXT NOT NULL,
    prediction TEXT NOT NULL,
    confidence DECIMAL(5, 4),
    target_price DECIMAL(12, 4),
    actual_price DECIMAL(12, 4),
    price_change_percent DECIMAL(8, 4),
    was_accurate BOOLEAN,
    timeframe TEXT,
    prediction_date TIMESTAMP WITH TIME ZONE,
    verified_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_prediction_history_symbol 
        FOREIGN KEY (symbol) 
        REFERENCES stocks(symbol) 
        ON DELETE CASCADE
);

-- Create indexes for prediction_history
CREATE INDEX IF NOT EXISTS idx_prediction_history_symbol_prediction_date 
ON prediction_history(symbol, prediction_date DESC);

-- Create market_data table for storing additional market information
CREATE TABLE IF NOT EXISTS market_data (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    symbol TEXT NOT NULL,
    data_type TEXT NOT NULL, -- 'technical', 'sentiment', 'volume', etc.
    data JSONB NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    CONSTRAINT fk_market_data_symbol 
        FOREIGN KEY (symbol) 
        REFERENCES stocks(symbol) 
        ON DELETE CASCADE
);

-- Create indexes for market_data
CREATE INDEX IF NOT EXISTS idx_market_data_symbol_type_created_at 
ON market_data(symbol, data_type, created_at DESC);

-- Create function to get latest price for a symbol
CREATE OR REPLACE FUNCTION get_latest_price(symbol_param TEXT)
RETURNS DECIMAL(12, 4) AS $$
BEGIN
    RETURN (
        SELECT price 
        FROM stock_prices 
        WHERE symbol = symbol_param 
        ORDER BY created_at DESC 
        LIMIT 1
    );
END;
$$ LANGUAGE plpgsql;

-- Create function to get recent sentiment for a symbol
CREATE OR REPLACE FUNCTION get_recent_sentiment(symbol_param TEXT, days INTEGER DEFAULT 7)
RETURNS TABLE (
    avg_sentiment DECIMAL(5, 4),
    article_count BIGINT,
    positive_count BIGINT,
    negative_count BIGINT,
    neutral_count BIGINT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        AVG(sentiment_compound) as avg_sentiment,
        COUNT(*) as article_count,
        SUM(CASE WHEN sentiment_compound > 0.05 THEN 1 ELSE 0 END) as positive_count,
        SUM(CASE WHEN sentiment_compound < -0.05 THEN 1 ELSE 0 END) as negative_count,
        SUM(CASE WHEN sentiment_compound >= -0.05 AND sentiment_compound <= 0.05 THEN 1 ELSE 0 END) as neutral_count
    FROM articles 
    WHERE symbol = symbol_param 
        AND published_at >= NOW() - INTERVAL '1 day' * days
        AND sentiment_compound IS NOT NULL;
END;
$$ LANGUAGE plpgsql;

-- Set up the automated pipeline
SELECT schedule_live_data_collection();

-- Grant necessary permissions
GRANT EXECUTE ON FUNCTION get_active_symbols() TO postgres;
GRANT EXECUTE ON FUNCTION get_latest_price(TEXT) TO postgres;
GRANT EXECUTE ON FUNCTION get_recent_sentiment(TEXT, INTEGER) TO postgres;
GRANT EXECUTE ON FUNCTION schedule_live_data_collection() TO postgres;

-- Add comments
COMMENT ON FUNCTION get_active_symbols() IS 'Returns all active stock symbols for data collection';
COMMENT ON FUNCTION get_latest_price(TEXT) IS 'Gets the most recent price for a symbol';
COMMENT ON FUNCTION get_recent_sentiment(TEXT, INTEGER) IS 'Calculates recent sentiment analysis for a symbol';
COMMENT ON FUNCTION schedule_live_data_collection() IS 'Sets up automated data collection schedules';
